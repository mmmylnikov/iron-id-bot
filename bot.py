import logging
import os
import re
import sys
from dataclasses import dataclass
from typing import cast
from uuid import uuid4

from telegram import (
    InlineQueryResultArticle,
    InputTextMessageContent,
    MessageOriginUser,
    Update,
)
from telegram.constants import ParseMode
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    InlineQueryHandler,
    MessageHandler,
    filters,
)

logging.basicConfig(
    format='%(asctime)s | %(levelname)s | %(message)s', level=logging.INFO
)
logging.getLogger('httpx').setLevel(logging.WARNING)

logger = logging.getLogger(__name__)


@dataclass
class MessageTemplate:
    """Simple message template style with title, emoji, and alias."""

    title: str
    emoji: str
    alias: str

    def full_msg_id(self, msg_id: str) -> str:
        """Return alias with message id."""
        return f'{self.alias}id: {msg_id}'

    def formated_msg_id(self, msg_id: str) -> str:
        """Return alias and copyable message id."""
        return f'#{self.alias}id: `{msg_id}`'

    def build_msg(self, query: str, msg_id: str) -> str:
        """Return full formated message."""
        return f'{query}\n\n{self.formated_msg_id(msg_id)}'


MESSAGE_TEMPLATES: tuple[MessageTemplate, ...] = (
    MessageTemplate('Irony', 'ðŸ¤¨', 'iron'),
    MessageTemplate('Sarcasm', 'ðŸ˜’', 'sarcasm'),
    MessageTemplate('Meme', 'ðŸ˜‚', 'meme'),
    MessageTemplate('Idea', 'ðŸ’¡', 'idea'),
)

MESSAGE_PATTERN = re.compile(r'#?(\w+id):\s*([0-9a-fA-F\-]+)')


def fetch_tag_from_message(
    message: str,
) -> MessageTemplate | None:
    """Return tag's template."""
    pattern = MESSAGE_PATTERN
    match = pattern.search(message)
    if not match:
        return None
    alias = match.group(1)
    alias = alias.removesuffix('id')

    msg_template = next(
        (template for template in MESSAGE_TEMPLATES if template.alias == alias),
        None,
    )
    if not msg_template:
        return None
    return msg_template


def fetch_uuid_from_message(
    message: str,
) -> str | None:
    """Return uuid."""
    pattern = MESSAGE_PATTERN
    match = pattern.search(message)
    if not match:
        return None
    return match.group(2)


BOT_TOKEN = os.getenv('BOT_TOKEN')
BOT_USERNAME = os.getenv('BOT_USERNAME')

START_REPLY = (
    "Hello! ðŸ‘‹ I'm a Telegram inline bot that adds a touch of humor to your "
    f'messages. Type your text after typing `@{BOT_USERNAME}` in any chat to '
    'get fun replies in Irony, Sarcasm, or Meme styles â€” each tagged with a '
    'unique UUID for easy tracking.\n\nUse /help to see how to use me.'
)

HELP_REPLY = (
    '*How to use this bot:*\n\n'
    f'1. In any chat, type `@{BOT_USERNAME}` <your message> (max 256 chars)\n'
    '2. Choose a style (Irony, Sarcasm, or Meme)\n'
    '3. Send the generated message with a unique UUID tag.\n\n'
    'ðŸ” Additionally, you can forward a message and the bot will verify '
    'if it was generated by it and provide confirmation.\n\n'
    'âœ¨ This makes your conversations more expressive and fun!'
)

UNCONFIRMED_FORWARDED_REPLY = (
    f'ðŸš« Sorry, @{BOT_USERNAME} cannot confirm this message.'
)
CONFIRMED_FORWARDED_REPLY = (
    'âœ… **CONFIRMED {style}**\n\n'
    '**UUID: `{uuid}`**\n'
    '**Date origin:** {date_origin}\n'
    '**User origin:** @{from_user}'
)


async def start_command(
    update: Update, context: ContextTypes.DEFAULT_TYPE
) -> None:
    """Handle the /start command by sending a welcome message."""
    if not update.message or not update.message.from_user:
        return
    logger.debug('Received /start from user %s', update.message.from_user.id)
    await update.message.reply_text(START_REPLY, parse_mode=ParseMode.MARKDOWN)


async def help_command(
    update: Update, context: ContextTypes.DEFAULT_TYPE
) -> None:
    """Handle the /help command by sending usage instructions."""
    if not update.message or not update.message.from_user:
        return
    logger.debug('Received /help from user %s', update.message.from_user.id)
    await update.message.reply_text(HELP_REPLY, parse_mode=ParseMode.MARKDOWN)


async def inline_query(
    update: Update, context: ContextTypes.DEFAULT_TYPE
) -> None:
    """Handle inline queries by returning message templates with UUID tags."""
    if not update.inline_query:
        return
    inline_query_text = update.inline_query.query
    message_uuid = str(uuid4())[:8]

    if not inline_query_text:
        return

    logger.debug(
        'Handling inline query: "%s" with UUID: %s',
        inline_query_text,
        message_uuid,
    )

    msg_templates = [
        InlineQueryResultArticle(
            id=str(uuid4()),
            title=f'{template.emoji} {template.title}',
            input_message_content=InputTextMessageContent(
                template.build_msg(inline_query_text, message_uuid),
                parse_mode=ParseMode.MARKDOWN,
            ),
            description=template.full_msg_id(message_uuid),
        )
        for template in MESSAGE_TEMPLATES
    ]

    await update.inline_query.answer(msg_templates)


async def check_forwarded_message(
    update: Update, context: ContextTypes.DEFAULT_TYPE
) -> None:
    """Confirm if a forwarded message was generated by the bot and respond."""
    if not update.message:
        return
    if (
        not update.message.text
        or not update.message.via_bot
        or update.message.via_bot.username != BOT_USERNAME
    ):
        await update.message.reply_text(UNCONFIRMED_FORWARDED_REPLY)
        return

    msg_template = fetch_tag_from_message(update.message.text)
    uuid = fetch_uuid_from_message(update.message.text)

    if not msg_template or not uuid or not update.message.forward_origin:
        await update.message.reply_text(UNCONFIRMED_FORWARDED_REPLY)
        return

    reply_text = CONFIRMED_FORWARDED_REPLY.format(
        uuid=uuid,
        style=msg_template.title.upper(),
        date_origin=update.message.forward_origin.date.strftime(
            '%d/%m/%Y, %H:%M:%S'
        ),
        from_user=cast(
            MessageOriginUser, update.message.forward_origin
        ).sender_user.username,
        via_bot=BOT_USERNAME,
    )
    await update.message.reply_text(reply_text, parse_mode=ParseMode.MARKDOWN)


def main() -> None:
    """Start the Telegram bot application."""
    if not BOT_TOKEN or not BOT_USERNAME:
        logger.error(
            'BOT_TOKEN and BOT_USERNAME must be set in environment variables.'
        )
        sys.exit('Missing BOT_TOKEN or BOT_USERNAME environment variables.')

    application = Application.builder().token(BOT_TOKEN).build()

    application.add_handler(
        CommandHandler('start', start_command, filters=filters.ChatType.PRIVATE)
    )
    application.add_handler(
        CommandHandler('help', help_command, filters=filters.ChatType.PRIVATE)
    )

    application.add_handler(InlineQueryHandler(inline_query))
    application.add_handler(
        MessageHandler(
            filters.ChatType.PRIVATE & filters.FORWARDED,
            check_forwarded_message,
        )
    )

    logger.info('Starting bot polling...')
    application.run_polling(allowed_updates=Update.ALL_TYPES)


if __name__ == '__main__':
    main()
